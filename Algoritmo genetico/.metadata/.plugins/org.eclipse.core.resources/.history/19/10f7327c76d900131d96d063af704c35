/*
 * main.c
 *
 *  Created on: 11/05/2014
 *      Author: igorsr
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define GEN_SIZE 10
#define POP_SIZE 100
#define TOURNAMENT_SIZE 3
#define P_CROSSOVER 0.8
#define P_MUTATION 0.001
#define GENERATIONS 2
#define ELISTIST_SIZE 1

typedef struct{
	char genotype[GEN_SIZE];
	float fitness;
}individual;

individual pop[POP_SIZE];

void initialize_population(individual * pop){

	int i,j;
	for(i=0; i< POP_SIZE;i++){
		for(j=0;j<GEN_SIZE;j++){
			pop[i].genotype[j] = rand() % 2;
		}
	}
}

float fitness_function(individual * p){

	float sum=0;
	int i;
	for(i=0; i<GEN_SIZE;i++){
		sum+=p->genotype[i] * pow(2,i);
	}
	return sum;
}

void evaluation(individual *pop){

	int i;
	for(i=0; i< POP_SIZE; i++){
		pop[i].fitness = fitness_function(&pop[i]);
	}
}

/*
 * Tournament selection
 */
int selection(int competitor, individual * pop){

	int i, winner = competitor;
	int partner;

	for(i=0; i< TOURNAMENT_SIZE; i++){

		partner = rand() % POP_SIZE;

		if(pop[partner].fitness > pop[winner].fitness){
			winner = partner;
		}
	}
#define GENERATIONS 2

	return winner;
}

/*
 * Single point crossover
 * */
void recombination(individual parents[2], individual offspring[2]){

	int point = rand() % GEN_SIZE;
	int i;

	for(i=0; i <= point;i++){
		offspring[0].genotype[i] = parents[0].genotype[i];
		offspring[1].genotype[i] = parents[1].genotype[i];
	}

	for(i=point+1; i <GEN_SIZE;i++){
		offspring[0].genotype[i] = parents[1].genotype[i];
		offspring[1].genotype[i] = parents[0].genotype[i];
	}
}

/*
  Bit-flip mutation
 * */
void mutation(individual *p){

	int i;
	for(i=0;i< GEN_SIZE; i++){
		if(rand()/RAND_MAX < P_CROSSOVER){
			p->genotype[i] = (p->genotype[i] + 1) % 2;
		}
	}
}


int compare_individuals(const void* a, const void* b){

	individual* p1 = (individual*)a;
	individual* p2 = (individual*)b;

    return p1->fitness < p2->fitness;
}


void population_replacement(individual *pop, individual * newPop){

	qsort(pop, POP_SIZE, sizeof(individual), (int(*)(const void*, const void*))compare_individuals);
	qsort(newPop, POP_SIZE, sizeof(individual), (int(*)(const void*, const void*))compare_individuals);

	//keeps elitist individuals
	int j = 0, l, i;
	for(i = ELISTIST_SIZE; i < POP_SIZE;i++,j++){

		for(l=0;l<GEN_SIZE;l++){
			pop[i].genotype[l] = newPop[j].genotype[l];
		}

	 }
}

void print_population(individual * pop){

	int i,j;

	for(i=0;i<POP_SIZE;i++){
		for(j=0;j<GEN_SIZE;j++)
			printf("%d",pop[i].genotype[j]);
		printf("==> %f\n", pop[i].fitness);
	}
}


void create_new_population(){

	int i;

	for(i=0;i<POP_SIZE-1;i++) {

		individual parents[2], offspring[2];

		torneio(i,   populacao, &pai1);
        torneio(i+1, populacao, &pai2);

        //Recombinação
        recombinacao(&pai1, &pai2, &filho1, &filho2, TAXA_DE_RECOMBINACAO);

        //Mutação
		mutacao(&filho1, TAXA_DE_MUTACAO);
		mutacao(&filho2, TAXA_DE_MUTACAO);


        filho1.aptidao = funcao_de_avaliacao(&filho1);
        filho2.aptidao = funcao_de_avaliacao(&filho2);

        adiciona_individuo(&filho1,i);
        adiciona_individuo(&filho2,++i);
	 }

	 //Ordena a geração atual
     qsort(populacao, TAMANHO_POPULACAO, sizeof(individuo), (int(*)(const void*, const void*))compara_individuo);

     //Ordena a nova geração
     qsort(copia_populacao, TAMANHO_POPULACAO, sizeof(individuo), (int(*)(const void*, const void*))compara_individuo);

     //Mantém a elite e substitui o restante pelos melhores da nova geração
     int j = 0, l;
     for(i = ELITE; i < TAMANHO_POPULACAO;i++,j++){

        for(l=0;l<TAMANHO_INDIVIDUO;l++){
            populacao[i].genotipo[l] = copia_populacao[j].genotipo[l];
        }

     }
}


int main(int argc, char **argv){

	individual pop[POP_SIZE], newPop[POP_SIZE];
	int generation=1;

	initialize_population(pop);

	evaluation(pop);

	//print_population(pop);

	while(generation <= GENERATIONS){

		create_new_population(pop, newPop);


	}





	return 0;
}
